# APEX CI/CD Workflow for ZenRead-AI-Reader-Mode-And-TTS-Browser-Extension

# This workflow is automatically generated by the Apex Technical Authority.
# It ensures consistent builds, tests, and deployments for the repository.
# Philosophy: Zero-Defect, High-Velocity, Future-Proof.

name: CI Workflow

# Controls when the workflow will run
on:
  push:
    branches: [ main ] # Trigger on pushes to the main branch
  pull_request:
    branches: [ main ] # Trigger on pull requests targeting the main branch
  workflow_dispatch: # Allows manual triggering

jobs:
  # Job to build and test the browser extension
  build_and_test:
    runs-on: ubuntu-latest # Use the latest Ubuntu runner

    strategy:
      matrix:
        node-version: [ '20.x' ] # Use Node.js 20.x for compatibility

    steps:
      # Step 1: Checkout the repository code
      - name: Checkout Repository
        uses: actions/checkout@v4

      # Step 2: Set up Node.js environment
      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm' # Cache npm dependencies for faster builds

      # Step 3: Install project dependencies
      - name: Install Dependencies
        run: npm ci # Use 'npm ci' for faster, reliable installs in CI

      # Step 4: Run Linters and Formatters (Biome)
      # Assuming Biome is configured for JavaScript/TypeScript projects
      # This step ensures code quality and consistency.
      - name: Lint and Format Code (Biome)
        run: npx @biomejs/biome check --apply-unsafe
        # Note: '--apply-unsafe' is used cautiously here for CI. For PRs, 'check' might be preferred.
        # If Biome is not yet installed globally or via devDependencies, adjust the command.

      # Step 5: Run Unit Tests (Vitest)
      # Vitest is a fast, Vite-native unit testing framework.
      - name: Run Unit Tests (Vitest)
        run: npm test
        # Assumes 'npm test' is configured to run Vitest tests.
        # Example vite.config.js might include vitest config.

      # Step 6: Build the browser extension (Vite)
      # Vite is used as the build tool for the extension.
      - name: Build Browser Extension (Vite)
        run: npm run build
        # Assumes 'npm run build' is configured to produce the extension files.
        # This typically outputs to a 'dist' or similar folder.

      # Step 7: Upload build artifacts (Optional, but recommended for later deployment/manual inspection)
      # This step stores the built extension files for potential later use.
      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: zenread-extension-build
          path: dist/ # Adjust 'path' if your build output is in a different directory

      # Step 8: Code Coverage Report (Codecov)
      # This step uploads coverage reports to Codecov for analysis.
      # Requires CODECOV_TOKEN to be set in GitHub secrets.
      - name: Upload Coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }} # Ensure CODECOV_TOKEN is set in repository secrets
          fail_ci_if_ குறைவாக: true # Fail the job if coverage drops below a threshold (optional, configurable)
          # name: zenread-extension # Optional: Specify a name for the coverage report

# Additional jobs can be added here for deployment, E2E testing, etc.
# For example, a job for deploying to Chrome Web Store or Firefox Add-ons could be added.
